/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CollapsibleCodeBlockPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  defaultCollapsed: false,
  collapseIcon: "\u25BC",
  expandIcon: "\u25B6",
  enableHorizontalScroll: true,
  collapsedLines: 0
};

// src/editView.ts
var import_view = require("@codemirror/view");
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_obsidian = require("obsidian");
var toggleFoldEffect = import_state.StateEffect.define();
var _FoldWidget = class extends import_view.WidgetType {
  constructor(startPos, endPos, settings, foldField, app) {
    super();
    this.startPos = startPos;
    this.endPos = endPos;
    this.settings = settings;
    this.foldField = foldField;
    this.app = app;
  }
  static getFrontmatterCodeBlockState(app) {
    var _a;
    const activeView = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!(activeView == null ? void 0 : activeView.file))
      return null;
    const cache = app.metadataCache.getFileCache(activeView.file);
    if (!((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["code-blocks"]))
      return null;
    const value = cache.frontmatter["code-blocks"].toLowerCase();
    return value === "collapsed" ? true : value === "expanded" ? false : null;
  }
  getBlockId() {
    var _a;
    const file = (_a = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a.file;
    return `${(file == null ? void 0 : file.path) || ""}-${this.startPos}-${this.endPos}`;
  }
  initializeCodeBlock(view) {
    const blockId = this.getBlockId();
    if (_FoldWidget.initializedBlocks.has(blockId)) {
      return;
    }
    _FoldWidget.initializedBlocks.add(blockId);
    const frontmatterState = _FoldWidget.getFrontmatterCodeBlockState(this.app);
    const shouldCollapse = frontmatterState !== null ? frontmatterState : this.settings.defaultCollapsed;
    if (shouldCollapse) {
      let isAlreadyFolded = false;
      view.state.field(this.foldField).between(this.startPos, this.endPos, () => {
        isAlreadyFolded = true;
      });
      if (!isAlreadyFolded) {
        requestAnimationFrame(() => {
          view.dispatch({
            effects: toggleFoldEffect.of({
              from: this.startPos,
              to: this.endPos,
              defaultState: true
            })
          });
        });
      }
    }
  }
  toDOM(view) {
    const button = document.createElement("div");
    button.className = "code-block-toggle";
    let isFolded = false;
    view.state.field(this.foldField).between(this.startPos, this.endPos, () => {
      isFolded = true;
    });
    this.initializeCodeBlock(view);
    button.innerHTML = isFolded ? this.settings.expandIcon : this.settings.collapseIcon;
    button.setAttribute("aria-label", isFolded ? "Expand code block" : "Collapse code block");
    button.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      view.dispatch({
        effects: toggleFoldEffect.of({
          from: this.startPos,
          to: this.endPos,
          defaultState: isFolded ? false : true
        })
      });
    };
    return button;
  }
  // Add method to clear initialization state when switching files
  static clearInitializedBlocks() {
    _FoldWidget.initializedBlocks.clear();
  }
};
var FoldWidget = _FoldWidget;
FoldWidget.initializedBlocks = /* @__PURE__ */ new Set();
var createFoldField = (settings) => import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(folds, tr) {
    folds = folds.map(tr.changes);
    for (let effect of tr.effects) {
      if (effect.is(toggleFoldEffect)) {
        const { from, to, defaultState } = effect.value;
        let hasFold = false;
        folds.between(from, to, () => {
          hasFold = true;
        });
        if (defaultState === false) {
          folds = folds.update({
            filter: (fromPos, toPos) => fromPos !== from || toPos !== to
          });
        } else {
          const capturedFrom = from;
          const capturedTo = to;
          const deco = import_view.Decoration.replace({
            block: true,
            inclusive: true,
            widget: new class extends import_view.WidgetType {
              toDOM(view) {
                const container = document.createElement("div");
                container.className = "code-block-folded";
                container.style.setProperty("--collapsed-lines", settings.collapsedLines.toString());
                const contentDiv = document.createElement("div");
                contentDiv.className = "folded-content";
                const lines = view.state.doc.sliceString(capturedFrom, capturedTo).split("\n").slice(0, settings.collapsedLines).join("\n");
                contentDiv.textContent = lines;
                const button = document.createElement("div");
                button.className = "code-block-toggle";
                button.textContent = settings.expandIcon;
                button.onclick = (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  view.dispatch({
                    effects: toggleFoldEffect.of({
                      from: capturedFrom,
                      to: capturedTo,
                      defaultState: false
                    })
                  });
                };
                container.appendChild(button);
                container.appendChild(contentDiv);
                return container;
              }
            }()
          });
          folds = folds.update({
            add: [deco.range(from, to)]
          });
        }
      }
    }
    return folds;
  },
  provide: (f) => import_view.EditorView.decorations.from(f)
});
var codeBlockPositions = import_state.StateField.define({
  create(state) {
    return findCodeBlockPositions(state);
  },
  update(value, tr) {
    return findCodeBlockPositions(tr.state);
  }
});
function findCodeBlockPositions(state) {
  const positions = [];
  (0, import_language.syntaxTree)(state).iterate({
    enter: (node) => {
      const nodeName = node.type.name;
      if (nodeName.includes("HyperMD-codeblock-begin")) {
        const lineEl = document.querySelector(`.${nodeName}`);
        if (lineEl && lineEl.parentElement) {
          lineEl.parentElement.classList.add("ccb-editor-codeblock");
        }
        const line = state.doc.lineAt(node.from);
        if (line.text.trim().startsWith("```")) {
          let endFound = false;
          for (let i = line.number; i <= state.doc.lines; i++) {
            const currentLine = state.doc.line(i);
            if (i !== line.number && currentLine.text.trim().startsWith("```")) {
              positions.push({
                startPos: line.from,
                endPos: currentLine.to
              });
              endFound = true;
              break;
            }
          }
          if (!endFound) {
            positions.push({
              startPos: line.from,
              endPos: state.doc.line(state.doc.lines).to
            });
          }
        }
      }
    }
  });
  return positions;
}
function buildDecorations(state, settings, foldField, app) {
  const widgets = [];
  const positions = state.field(codeBlockPositions);
  positions.forEach((pos) => {
    const widget = import_view.Decoration.widget({
      widget: new FoldWidget(pos.startPos, pos.endPos, settings, foldField, app),
      // Pass app as the fifth argument
      side: -1
    });
    widgets.push(widget.range(pos.startPos));
  });
  return import_view.Decoration.set(widgets, true);
}
function setupEditView(settings, app) {
  const foldField = createFoldField(settings);
  const currentDecorations = import_state.StateField.define({
    create(state) {
      return buildDecorations(state, settings, foldField, app);
    },
    update(value, transaction) {
      return buildDecorations(transaction.state, settings, foldField, app);
    },
    provide(field) {
      return import_view.EditorView.decorations.from(field);
    }
  });
  return [
    codeBlockPositions,
    foldField,
    currentDecorations
  ];
}

// src/readView.ts
var import_obsidian2 = require("obsidian");
function setupReadView(app, settings) {
  function getFrontmatterCodeBlockState() {
    var _a;
    const activeView = app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!(activeView == null ? void 0 : activeView.file))
      return null;
    const cache = app.metadataCache.getFileCache(activeView.file);
    if (!((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["code-blocks"]))
      return null;
    const value = cache.frontmatter["code-blocks"].toLowerCase();
    if (value === "collapsed")
      return true;
    if (value === "expanded")
      return false;
    return null;
  }
  function createToggleButton() {
    const button = document.createElement("div");
    button.className = "code-block-toggle";
    button.textContent = settings.collapseIcon;
    button.setAttribute("role", "button");
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-label", "Toggle code block visibility");
    const toggleHandler = (e) => {
      e.preventDefault();
      const pre = e.target.closest("pre");
      if (!pre)
        return;
      pre.classList.toggle("collapsed");
      updateCodeBlockVisibility(pre, true);
      const isCollapsed = pre.classList.contains("collapsed");
      button.textContent = isCollapsed ? settings.expandIcon : settings.collapseIcon;
      button.setAttribute("aria-expanded", (!isCollapsed).toString());
      app.workspace.requestSaveLayout();
    };
    button.addEventListener("click", toggleHandler);
    button.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        toggleHandler(e);
      }
    });
    return button;
  }
  function updateCodeBlockVisibility(pre, forceRefresh = false) {
    var _a;
    const isCollapsed = pre.classList.contains("collapsed");
    const markdownView = app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!((_a = markdownView == null ? void 0 : markdownView.previewMode) == null ? void 0 : _a.containerEl))
      return;
    const previewElement = markdownView.previewMode.containerEl;
    const rect = pre.getBoundingClientRect();
    const scrollTop = previewElement.scrollTop;
    const elementTop = rect.top + scrollTop;
    let curr = pre.nextElementSibling;
    while (curr && !(curr instanceof HTMLPreElement)) {
      if (curr instanceof HTMLElement) {
        if (isCollapsed) {
          curr.classList.add("element-hidden");
          curr.classList.remove("element-visible", "element-spacing");
        } else {
          curr.classList.remove("element-hidden");
          curr.classList.add("element-visible");
        }
      }
      curr = curr.nextElementSibling;
    }
    void pre.offsetHeight;
    const triggerReflow = async () => {
      window.dispatchEvent(new Event("resize"));
      await new Promise((resolve) => requestAnimationFrame(resolve));
      const originalScroll = previewElement.scrollTop;
      previewElement.scrollTop = Math.max(0, previewElement.scrollHeight - previewElement.clientHeight);
      await new Promise((resolve) => requestAnimationFrame(resolve));
      previewElement.scrollTop = originalScroll;
      window.dispatchEvent(new Event("resize"));
      await new Promise((resolve) => setTimeout(resolve, 50));
      window.dispatchEvent(new Event("resize"));
    };
    triggerReflow();
  }
  function setupCodeBlock(pre) {
    document.documentElement.style.setProperty("--collapsed-lines", settings.collapsedLines.toString());
    const toggleButton = createToggleButton();
    pre.insertBefore(toggleButton, pre.firstChild);
    const frontmatterState = getFrontmatterCodeBlockState();
    const shouldCollapse = frontmatterState !== null ? frontmatterState : settings.defaultCollapsed;
    if (shouldCollapse) {
      pre.classList.add("collapsed");
      toggleButton.textContent = settings.expandIcon;
      updateCodeBlockVisibility(pre, true);
    }
  }
  function processNewCodeBlocks(element) {
    element.querySelectorAll("pre:not(.has-collapse-button)").forEach((pre) => {
      if (!(pre instanceof HTMLElement))
        return;
      pre.classList.add("has-collapse-button", "ccb-code-block");
      const codeElement = pre.querySelector("code");
      if (codeElement) {
        codeElement.classList.add("ccb-hide-vertical-scrollbar");
      }
      setupCodeBlock(pre);
    });
  }
  function setupContentObserver(processNewCodeBlocks2) {
    return new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          processNewCodeBlocks2(mutation.target);
        }
      });
    });
  }
  return {
    processNewCodeBlocks,
    setupContentObserver
  };
}

// src/main.ts
var CollapsibleCodeBlockPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.updateScrollSetting();
    document.documentElement.style.setProperty("--collapsed-lines", this.settings.collapsedLines.toString());
    const editorExtensions = setupEditView(this.settings, this.app);
    this.registerEditorExtension(editorExtensions);
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        FoldWidget.clearInitializedBlocks();
      })
    );
    this.readViewAPI = setupReadView(this.app, this.settings);
    this.contentObserver = this.readViewAPI.setupContentObserver(this.readViewAPI.processNewCodeBlocks);
    this.registerMarkdownPostProcessor((element) => {
      this.readViewAPI.processNewCodeBlocks(element);
      this.contentObserver.observe(element, { childList: true, subtree: true });
    });
    this.addSettingTab(new CollapsibleCodeBlockSettingTab(this.app, this));
  }
  updateScrollSetting() {
    document.body.setAttribute("data-ccb-horizontal-scroll", this.settings.enableHorizontalScroll.toString());
  }
  sanitizeIcon(icon) {
    const cleaned = icon.trim();
    if (cleaned.length <= 2) {
      return cleaned;
    } else {
      if (this.app.customIcons && this.app.customIcons.exists(cleaned)) {
        return cleaned;
      }
      return DEFAULT_SETTINGS.collapseIcon;
    }
  }
  async loadSettings() {
    var _a, _b;
    const loadedData = await this.loadData();
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...loadedData,
      collapseIcon: this.sanitizeIcon((_a = loadedData == null ? void 0 : loadedData.collapseIcon) != null ? _a : DEFAULT_SETTINGS.collapseIcon),
      expandIcon: this.sanitizeIcon((_b = loadedData == null ? void 0 : loadedData.expandIcon) != null ? _b : DEFAULT_SETTINGS.expandIcon)
    };
  }
  async saveSettings() {
    this.settings.collapseIcon = this.sanitizeIcon(this.settings.collapseIcon);
    this.settings.expandIcon = this.sanitizeIcon(this.settings.expandIcon);
    await this.saveData(this.settings);
  }
  onunload() {
    var _a;
    (_a = this.contentObserver) == null ? void 0 : _a.disconnect();
    document.body.removeAttribute("data-ccb-horizontal-scroll");
  }
};
var CollapsibleCodeBlockSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.app = app;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Default collapsed state").setDesc("Should code blocks be collapsed by default?").addToggle((toggle) => toggle.setValue(this.plugin.settings.defaultCollapsed).onChange(async (value) => {
      this.plugin.settings.defaultCollapsed = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Collapse icon").setDesc("Icon to show when code block is expanded (single character or emoji only)").addText((text) => text.setValue(this.plugin.settings.collapseIcon).onChange(async (value) => {
      const sanitized = value.trim();
      if (sanitized.length <= 2) {
        this.plugin.settings.collapseIcon = sanitized || DEFAULT_SETTINGS.collapseIcon;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian3.Setting(containerEl).setName("Expand icon").setDesc("Icon to show when code block is collapsed (single character or emoji only)").addText((text) => text.setValue(this.plugin.settings.expandIcon).onChange(async (value) => {
      const sanitized = value.trim();
      if (sanitized.length <= 2) {
        this.plugin.settings.expandIcon = sanitized || DEFAULT_SETTINGS.expandIcon;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian3.Setting(containerEl).setName("Enable horizontal scrolling").setDesc("Allow code blocks to scroll horizontally instead of wrapping text.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableHorizontalScroll).onChange(async (value) => {
      this.plugin.settings.enableHorizontalScroll = value;
      await this.plugin.saveSettings();
      this.plugin.updateScrollSetting();
    }));
    const collapsedLinesSetting = new import_obsidian3.Setting(containerEl).setName("Collapsed lines").setDesc("Number of lines visible when code block is collapsed");
    collapsedLinesSetting.addText((text) => {
      text.setValue(this.plugin.settings.collapsedLines.toString()).onChange(async (value) => {
        const numericValue = parseInt(value, 10);
        this.plugin.settings.collapsedLines = isNaN(numericValue) || numericValue < 0 ? 0 : numericValue;
        await this.plugin.saveSettings();
        document.documentElement.style.setProperty("--collapsed-lines", this.plugin.settings.collapsedLines.toString());
      });
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3R5cGVzLnRzIiwgInNyYy9lZGl0Vmlldy50cyIsICJzcmMvcmVhZFZpZXcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IFBsdWdpbiwgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBCdXR0b25Db21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBDb2xsYXBzaWJsZUNvZGVCbG9ja1NldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTLCBFeHRlbmRlZEFwcCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgc2V0dXBFZGl0VmlldywgRm9sZFdpZGdldCB9IGZyb20gJy4vZWRpdFZpZXcnO1xuaW1wb3J0IHsgc2V0dXBSZWFkVmlldywgdHlwZSBSZWFkVmlld0FQSSB9IGZyb20gJy4vcmVhZFZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xsYXBzaWJsZUNvZGVCbG9ja1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG4gICAgcHJpdmF0ZSBjb250ZW50T2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgcHVibGljIHNldHRpbmdzOiBDb2xsYXBzaWJsZUNvZGVCbG9ja1NldHRpbmdzO1xuICAgIHByaXZhdGUgcmVhZFZpZXdBUEk6IFJlYWRWaWV3QVBJO1xuXG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbFNldHRpbmcoKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBDU1MgdmFyaWFibGVzXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb2xsYXBzZWQtbGluZXMnLCB0aGlzLnNldHRpbmdzLmNvbGxhcHNlZExpbmVzLnRvU3RyaW5nKCkpO1xuICAgICAgICAvLyBTZXQgdXAgZWRpdG9yIHZpZXcgd2l0aCBhcHAgaW5zdGFuY2VcbiAgICAgICAgY29uc3QgZWRpdG9yRXh0ZW5zaW9ucyA9IHNldHVwRWRpdFZpZXcodGhpcy5zZXR0aW5ncywgdGhpcy5hcHApO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRWRpdG9yRXh0ZW5zaW9uKGVkaXRvckV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgdGhpcy5hcHAud29ya3NwYWNlLm9uKCdmaWxlLW9wZW4nLCAoKSA9PiB7XG4gICAgICAgIEZvbGRXaWRnZXQuY2xlYXJJbml0aWFsaXplZEJsb2NrcygpO1xuICAgIH0pXG4pO1xuXG4gICAgICAgIC8vIFNldCB1cCByZWFkaW5nIHZpZXdcbiAgICAgICAgdGhpcy5yZWFkVmlld0FQSSA9IHNldHVwUmVhZFZpZXcodGhpcy5hcHAgYXMgRXh0ZW5kZWRBcHAsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLmNvbnRlbnRPYnNlcnZlciA9IHRoaXMucmVhZFZpZXdBUEkuc2V0dXBDb250ZW50T2JzZXJ2ZXIodGhpcy5yZWFkVmlld0FQSS5wcm9jZXNzTmV3Q29kZUJsb2Nrcyk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duUG9zdFByb2Nlc3NvcigoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFkVmlld0FQSS5wcm9jZXNzTmV3Q29kZUJsb2NrcyhlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudE9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgQ29sbGFwc2libGVDb2RlQmxvY2tTZXR0aW5nVGFiKHRoaXMuYXBwIGFzIEV4dGVuZGVkQXBwLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlU2Nyb2xsU2V0dGluZygpOiB2b2lkIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoJ2RhdGEtY2NiLWhvcml6b250YWwtc2Nyb2xsJywgdGhpcy5zZXR0aW5ncy5lbmFibGVIb3Jpem9udGFsU2Nyb2xsLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2FuaXRpemVJY29uKGljb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGNsZWFuZWQgPSBpY29uLnRyaW0oKTtcbiAgICAgICAgaWYgKGNsZWFuZWQubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHZhbGlkIE9ic2lkaWFuIGljb24gbmFtZVxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwLmN1c3RvbUljb25zICYmIHRoaXMuYXBwLmN1c3RvbUljb25zLmV4aXN0cyhjbGVhbmVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfU0VUVElOR1MuY29sbGFwc2VJY29uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBsb2FkZWREYXRhID0gYXdhaXQgdGhpcy5sb2FkRGF0YSgpO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TRVRUSU5HUyxcbiAgICAgICAgICAgIC4uLmxvYWRlZERhdGEsXG4gICAgICAgICAgICBjb2xsYXBzZUljb246IHRoaXMuc2FuaXRpemVJY29uKGxvYWRlZERhdGE/LmNvbGxhcHNlSWNvbiA/PyBERUZBVUxUX1NFVFRJTkdTLmNvbGxhcHNlSWNvbiksXG4gICAgICAgICAgICBleHBhbmRJY29uOiB0aGlzLnNhbml0aXplSWNvbihsb2FkZWREYXRhPy5leHBhbmRJY29uID8/IERFRkFVTFRfU0VUVElOR1MuZXhwYW5kSWNvbilcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29sbGFwc2VJY29uID0gdGhpcy5zYW5pdGl6ZUljb24odGhpcy5zZXR0aW5ncy5jb2xsYXBzZUljb24pO1xuICAgICAgICB0aGlzLnNldHRpbmdzLmV4cGFuZEljb24gPSB0aGlzLnNhbml0aXplSWNvbih0aGlzLnNldHRpbmdzLmV4cGFuZEljb24pO1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnRPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1jY2ItaG9yaXpvbnRhbC1zY3JvbGwnKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbGxhcHNpYmxlQ29kZUJsb2NrU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogQ29sbGFwc2libGVDb2RlQmxvY2tQbHVnaW47XG4gICAgYXBwOiBFeHRlbmRlZEFwcDtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IENvbGxhcHNpYmxlQ29kZUJsb2NrUGx1Z2luKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKTtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHAgYXMgRXh0ZW5kZWRBcHA7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgIH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgY29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdEZWZhdWx0IGNvbGxhcHNlZCBzdGF0ZScpXG4gICAgICAgIC5zZXREZXNjKCdTaG91bGQgY29kZSBibG9ja3MgYmUgY29sbGFwc2VkIGJ5IGRlZmF1bHQ/JylcbiAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdENvbGxhcHNlZClcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0Q29sbGFwc2VkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoJ0NvbGxhcHNlIGljb24nKVxuICAgICAgICAuc2V0RGVzYygnSWNvbiB0byBzaG93IHdoZW4gY29kZSBibG9jayBpcyBleHBhbmRlZCAoc2luZ2xlIGNoYXJhY3RlciBvciBlbW9qaSBvbmx5KScpXG4gICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbGxhcHNlSWNvbilcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWQgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNhbml0aXplZC5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb2xsYXBzZUljb24gPSBzYW5pdGl6ZWQgfHwgREVGQVVMVF9TRVRUSU5HUy5jb2xsYXBzZUljb247XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZSgnRXhwYW5kIGljb24nKVxuICAgICAgICAuc2V0RGVzYygnSWNvbiB0byBzaG93IHdoZW4gY29kZSBibG9jayBpcyBjb2xsYXBzZWQgKHNpbmdsZSBjaGFyYWN0ZXIgb3IgZW1vamkgb25seSknKVxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5leHBhbmRJY29uKVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoc2FuaXRpemVkLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4cGFuZEljb24gPSBzYW5pdGl6ZWQgfHwgREVGQVVMVF9TRVRUSU5HUy5leHBhbmRJY29uO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoJ0VuYWJsZSBob3Jpem9udGFsIHNjcm9sbGluZycpXG4gICAgICAgIC5zZXREZXNjKCdBbGxvdyBjb2RlIGJsb2NrcyB0byBzY3JvbGwgaG9yaXpvbnRhbGx5IGluc3RlYWQgb2Ygd3JhcHBpbmcgdGV4dC4nKVxuICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbmFibGVIb3Jpem9udGFsU2Nyb2xsKVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZUhvcml6b250YWxTY3JvbGwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi51cGRhdGVTY3JvbGxTZXR0aW5nKCk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICBjb25zdCBjb2xsYXBzZWRMaW5lc1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoJ0NvbGxhcHNlZCBsaW5lcycpXG4gICAgICAgIC5zZXREZXNjKCdOdW1iZXIgb2YgbGluZXMgdmlzaWJsZSB3aGVuIGNvZGUgYmxvY2sgaXMgY29sbGFwc2VkJyk7XG5cbiAgICAvLyBObyByZWxvYWQgYnV0dG9uIG5lZWRlZCBhcyBzZXR0aW5ncyB3aWxsIGFwcGx5IGF1dG9tYXRpY2FsbHlcblxuICAgIGNvbGxhcHNlZExpbmVzU2V0dGluZy5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICB0ZXh0XG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY29sbGFwc2VkTGluZXMudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1lcmljVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbGxhcHNlZExpbmVzID0gaXNOYU4obnVtZXJpY1ZhbHVlKSB8fCBudW1lcmljVmFsdWUgPCAwID8gMCA6IG51bWVyaWNWYWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBzZXR0aW5ncyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1jb2xsYXBzZWQtbGluZXMnLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb2xsYXBzZWRMaW5lcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0pO1xuICAgIH1cbn0iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbGxhcHNpYmxlQ29kZUJsb2NrU2V0dGluZ3Mge1xuICAgIGRlZmF1bHRDb2xsYXBzZWQ6IGJvb2xlYW47XG4gICAgY29sbGFwc2VJY29uOiBzdHJpbmc7XG4gICAgZXhwYW5kSWNvbjogc3RyaW5nO1xuICAgIGVuYWJsZUhvcml6b250YWxTY3JvbGw6IGJvb2xlYW47XG4gICAgY29sbGFwc2VkTGluZXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IENvbGxhcHNpYmxlQ29kZUJsb2NrU2V0dGluZ3MgPSB7XG4gICAgZGVmYXVsdENvbGxhcHNlZDogZmFsc2UsXG4gICAgY29sbGFwc2VJY29uOiAnXHUyNUJDJyxcbiAgICBleHBhbmRJY29uOiAnXHUyNUI2JyxcbiAgICBlbmFibGVIb3Jpem9udGFsU2Nyb2xsOiB0cnVlLFxuICAgIGNvbGxhcHNlZExpbmVzOiAwXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVuZGVkUGx1Z2luQVBJIHtcbiAgICBkaXNhYmxlUGx1Z2luKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICAgIGVuYWJsZVBsdWdpbihpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHRlbmRlZEFwcCBleHRlbmRzIEFwcCB7XG4gICAgcGx1Z2luczogRXh0ZW5kZWRQbHVnaW5BUEk7XG59IiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcsIERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIFdpZGdldFR5cGUgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHN5bnRheFRyZWUgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBTdGF0ZUZpZWxkLCBTdGF0ZUVmZmVjdCwgRWRpdG9yU3RhdGUgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBDb2xsYXBzaWJsZUNvZGVCbG9ja1NldHRpbmdzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBBcHAsIE1hcmtkb3duVmlldyB9IGZyb20gJ29ic2lkaWFuJztcblxuaW50ZXJmYWNlIENvZGVCbG9ja1Bvc2l0aW9uIHtcbiAgICBzdGFydFBvczogbnVtYmVyO1xuICAgIGVuZFBvczogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgdG9nZ2xlRm9sZEVmZmVjdCA9IFN0YXRlRWZmZWN0LmRlZmluZTx7ZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCBkZWZhdWx0U3RhdGU/OiBib29sZWFufT4oKTtcblxuZXhwb3J0IGNsYXNzIEZvbGRXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbml0aWFsaXplZEJsb2NrcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RnJvbnRtYXR0ZXJDb2RlQmxvY2tTdGF0ZShhcHA6IEFwcCk6IGJvb2xlYW4gfCBudWxsIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICBpZiAoIWFjdGl2ZVZpZXc/LmZpbGUpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBjYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShhY3RpdmVWaWV3LmZpbGUpO1xuICAgICAgICBpZiAoIWNhY2hlPy5mcm9udG1hdHRlcj8uWydjb2RlLWJsb2NrcyddKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjYWNoZS5mcm9udG1hdHRlclsnY29kZS1ibG9ja3MnXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICdjb2xsYXBzZWQnID8gdHJ1ZSA6IHZhbHVlID09PSAnZXhwYW5kZWQnID8gZmFsc2UgOiBudWxsO1xuICAgIH1cbiAgICBcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcmVhZG9ubHkgc3RhcnRQb3M6IG51bWJlcixcbiAgICAgICAgcmVhZG9ubHkgZW5kUG9zOiBudW1iZXIsXG4gICAgICAgIHJlYWRvbmx5IHNldHRpbmdzOiBDb2xsYXBzaWJsZUNvZGVCbG9ja1NldHRpbmdzLFxuICAgICAgICByZWFkb25seSBmb2xkRmllbGQ6IFN0YXRlRmllbGQ8RGVjb3JhdGlvblNldD4sXG4gICAgICAgIHJlYWRvbmx5IGFwcDogQXBwXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRCbG9ja0lkKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpPy5maWxlO1xuICAgICAgICByZXR1cm4gYCR7ZmlsZT8ucGF0aCB8fCAnJ30tJHt0aGlzLnN0YXJ0UG9zfS0ke3RoaXMuZW5kUG9zfWA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplQ29kZUJsb2NrKHZpZXc6IEVkaXRvclZpZXcpIHtcbiAgICAgICAgY29uc3QgYmxvY2tJZCA9IHRoaXMuZ2V0QmxvY2tJZCgpO1xuICAgICAgICBpZiAoRm9sZFdpZGdldC5pbml0aWFsaXplZEJsb2Nrcy5oYXMoYmxvY2tJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIEZvbGRXaWRnZXQuaW5pdGlhbGl6ZWRCbG9ja3MuYWRkKGJsb2NrSWQpO1xuICAgICAgICBjb25zdCBmcm9udG1hdHRlclN0YXRlID0gRm9sZFdpZGdldC5nZXRGcm9udG1hdHRlckNvZGVCbG9ja1N0YXRlKHRoaXMuYXBwKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ29sbGFwc2UgPSBmcm9udG1hdHRlclN0YXRlICE9PSBudWxsID8gZnJvbnRtYXR0ZXJTdGF0ZSA6IHRoaXMuc2V0dGluZ3MuZGVmYXVsdENvbGxhcHNlZDtcbiAgICAgICAgXG4gICAgICAgIGlmIChzaG91bGRDb2xsYXBzZSkge1xuICAgICAgICAgICAgbGV0IGlzQWxyZWFkeUZvbGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmlldy5zdGF0ZS5maWVsZCh0aGlzLmZvbGRGaWVsZCkuYmV0d2Vlbih0aGlzLnN0YXJ0UG9zLCB0aGlzLmVuZFBvcywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzQWxyZWFkeUZvbGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFpc0FscmVhZHlGb2xkZWQpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IHRvZ2dsZUZvbGRFZmZlY3Qub2Yoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMuc3RhcnRQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuZW5kUG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdG9ET00odmlldzogRWRpdG9yVmlldykge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICdjb2RlLWJsb2NrLXRvZ2dsZSc7XG4gICAgICAgIFxuICAgICAgICBsZXQgaXNGb2xkZWQgPSBmYWxzZTtcbiAgICAgICAgdmlldy5zdGF0ZS5maWVsZCh0aGlzLmZvbGRGaWVsZCkuYmV0d2Vlbih0aGlzLnN0YXJ0UG9zLCB0aGlzLmVuZFBvcywgKCkgPT4ge1xuICAgICAgICAgICAgaXNGb2xkZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvZGVCbG9jayh2aWV3KTtcbiAgICAgICAgXG4gICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBpc0ZvbGRlZCA/IHRoaXMuc2V0dGluZ3MuZXhwYW5kSWNvbiA6IHRoaXMuc2V0dGluZ3MuY29sbGFwc2VJY29uO1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgaXNGb2xkZWQgPyAnRXhwYW5kIGNvZGUgYmxvY2snIDogJ0NvbGxhcHNlIGNvZGUgYmxvY2snKTtcbiAgICAgICAgXG4gICAgICAgIGJ1dHRvbi5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiB0b2dnbGVGb2xkRWZmZWN0Lm9mKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhpcy5zdGFydFBvcyxcbiAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuZW5kUG9zLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGU6IGlzRm9sZGVkID8gZmFsc2UgOiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kIHRvIGNsZWFyIGluaXRpYWxpemF0aW9uIHN0YXRlIHdoZW4gc3dpdGNoaW5nIGZpbGVzXG4gICAgcHVibGljIHN0YXRpYyBjbGVhckluaXRpYWxpemVkQmxvY2tzKCkge1xuICAgICAgICBGb2xkV2lkZ2V0LmluaXRpYWxpemVkQmxvY2tzLmNsZWFyKCk7XG4gICAgfVxufVxuXG5jb25zdCBjcmVhdGVGb2xkRmllbGQgPSAoc2V0dGluZ3M6IENvbGxhcHNpYmxlQ29kZUJsb2NrU2V0dGluZ3MpID0+IFN0YXRlRmllbGQuZGVmaW5lPERlY29yYXRpb25TZXQ+KHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfSxcbiAgICB1cGRhdGUoZm9sZHM6IERlY29yYXRpb25TZXQsIHRyKSB7XG4gICAgICAgIGZvbGRzID0gZm9sZHMubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXModG9nZ2xlRm9sZEVmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZyb20sIHRvLCBkZWZhdWx0U3RhdGUgfSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzRm9sZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvbGRzLmJldHdlZW4oZnJvbSwgdG8sICgpID0+IHsgaGFzRm9sZCA9IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRTdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZHMgPSBmb2xkcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAoZnJvbVBvcywgdG9Qb3MpID0+IGZyb21Qb3MgIT09IGZyb20gfHwgdG9Qb3MgIT09IHRvXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkRnJvbSA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkVG8gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY28gPSBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvRE9NKHZpZXc6IEVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSAnY29kZS1ibG9jay1mb2xkZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoJy0tY29sbGFwc2VkLWxpbmVzJywgc2V0dGluZ3MuY29sbGFwc2VkTGluZXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ2ZvbGRlZC1jb250ZW50JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSB2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhjYXB0dXJlZEZyb20sIGNhcHR1cmVkVG8pLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIHNldHRpbmdzLmNvbGxhcHNlZExpbmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gbGluZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICdjb2RlLWJsb2NrLXRvZ2dsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHNldHRpbmdzLmV4cGFuZEljb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiB0b2dnbGVGb2xkRWZmZWN0Lm9mKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogY2FwdHVyZWRGcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogY2FwdHVyZWRUbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvbGRzID0gZm9sZHMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZDogW2RlY28ucmFuZ2UoZnJvbSwgdG8pXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRzO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuXG5jb25zdCBjb2RlQmxvY2tQb3NpdGlvbnMgPSBTdGF0ZUZpZWxkLmRlZmluZTxDb2RlQmxvY2tQb3NpdGlvbltdPih7XG4gICAgY3JlYXRlKHN0YXRlOiBFZGl0b3JTdGF0ZSk6IENvZGVCbG9ja1Bvc2l0aW9uW10ge1xuICAgICAgICByZXR1cm4gZmluZENvZGVCbG9ja1Bvc2l0aW9ucyhzdGF0ZSk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWU6IENvZGVCbG9ja1Bvc2l0aW9uW10sIHRyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29kZUJsb2NrUG9zaXRpb25zKHRyLnN0YXRlKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gZmluZENvZGVCbG9ja1Bvc2l0aW9ucyhzdGF0ZTogRWRpdG9yU3RhdGUpOiBDb2RlQmxvY2tQb3NpdGlvbltdIHtcbiAgICBjb25zdCBwb3NpdGlvbnM6IENvZGVCbG9ja1Bvc2l0aW9uW10gPSBbXTtcbiAgICBcbiAgICBzeW50YXhUcmVlKHN0YXRlKS5pdGVyYXRlKHtcbiAgICAgICAgZW50ZXI6IChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUudHlwZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lLmluY2x1ZGVzKFwiSHlwZXJNRC1jb2RlYmxvY2stYmVnaW5cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgb3VyIGN1c3RvbSBjbGFzcyB0byBjb2RlIGJsb2NrcyBpbiBlZGl0b3JcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuJHtub2RlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUVsICYmIGxpbmVFbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVFbC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2NjYi1lZGl0b3ItY29kZWJsb2NrJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KG5vZGUuZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dC50cmltKCkuc3RhcnRzV2l0aCgnYGBgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGluZS5udW1iZXI7IGkgPD0gc3RhdGUuZG9jLmxpbmVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gbGluZS5udW1iZXIgJiYgY3VycmVudExpbmUudGV4dC50cmltKCkuc3RhcnRzV2l0aCgnYGBgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zOiBsaW5lLmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvczogY3VycmVudExpbmUudG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5kRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBvczogbGluZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvczogc3RhdGUuZG9jLmxpbmUoc3RhdGUuZG9jLmxpbmVzKS50b1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcG9zaXRpb25zO1xufVxuXG5mdW5jdGlvbiBidWlsZERlY29yYXRpb25zKFxuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZSwgXG4gICAgc2V0dGluZ3M6IENvbGxhcHNpYmxlQ29kZUJsb2NrU2V0dGluZ3MsXG4gICAgZm9sZEZpZWxkOiBTdGF0ZUZpZWxkPERlY29yYXRpb25TZXQ+LFxuICAgIGFwcDogQXBwICAvLyBBZGQgYXBwIHBhcmFtZXRlclxuKTogRGVjb3JhdGlvblNldCB7XG4gICAgY29uc3Qgd2lkZ2V0czogYW55W10gPSBbXTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBzdGF0ZS5maWVsZChjb2RlQmxvY2tQb3NpdGlvbnMpO1xuICAgIFxuICAgIHBvc2l0aW9ucy5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICAgIGNvbnN0IHdpZGdldCA9IERlY29yYXRpb24ud2lkZ2V0KHtcbiAgICAgICAgICAgIHdpZGdldDogbmV3IEZvbGRXaWRnZXQocG9zLnN0YXJ0UG9zLCBwb3MuZW5kUG9zLCBzZXR0aW5ncywgZm9sZEZpZWxkLCBhcHApLCAvLyBQYXNzIGFwcCBhcyB0aGUgZmlmdGggYXJndW1lbnRcbiAgICAgICAgICAgIHNpZGU6IC0xXG4gICAgICAgIH0pO1xuICAgICAgICB3aWRnZXRzLnB1c2god2lkZ2V0LnJhbmdlKHBvcy5zdGFydFBvcykpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBEZWNvcmF0aW9uLnNldCh3aWRnZXRzLCB0cnVlKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBFZGl0VmlldyhzZXR0aW5nczogQ29sbGFwc2libGVDb2RlQmxvY2tTZXR0aW5ncywgYXBwOiBBcHApOiBFeHRlbnNpb25bXSB7XG4gICAgY29uc3QgZm9sZEZpZWxkID0gY3JlYXRlRm9sZEZpZWxkKHNldHRpbmdzKTtcbiAgICBjb25zdCBjdXJyZW50RGVjb3JhdGlvbnMgPSBTdGF0ZUZpZWxkLmRlZmluZTxEZWNvcmF0aW9uU2V0Pih7XG4gICAgICAgIGNyZWF0ZShzdGF0ZTogRWRpdG9yU3RhdGUpOiBEZWNvcmF0aW9uU2V0IHtcbiAgICAgICAgICAgIHJldHVybiBidWlsZERlY29yYXRpb25zKHN0YXRlLCBzZXR0aW5ncywgZm9sZEZpZWxkLCBhcHApO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUodmFsdWU6IERlY29yYXRpb25TZXQsIHRyYW5zYWN0aW9uKTogRGVjb3JhdGlvblNldCB7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGREZWNvcmF0aW9ucyh0cmFuc2FjdGlvbi5zdGF0ZSwgc2V0dGluZ3MsIGZvbGRGaWVsZCwgYXBwKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdmlkZShmaWVsZDogU3RhdGVGaWVsZDxEZWNvcmF0aW9uU2V0Pik6IEV4dGVuc2lvbiB7XG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGZpZWxkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29kZUJsb2NrUG9zaXRpb25zLFxuICAgICAgICBmb2xkRmllbGQsXG4gICAgICAgIGN1cnJlbnREZWNvcmF0aW9uc1xuICAgIF07XG59XG4iLCAiaW1wb3J0IHsgTWFya2Rvd25WaWV3IH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQ29sbGFwc2libGVDb2RlQmxvY2tTZXR0aW5ncywgRXh0ZW5kZWRBcHAgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBSZWFkVmlld0FQSSB7XG4gICAgcHJvY2Vzc05ld0NvZGVCbG9ja3M6IChlbGVtZW50OiBIVE1MRWxlbWVudCkgPT4gdm9pZDtcbiAgICBzZXR1cENvbnRlbnRPYnNlcnZlcjogKHByb2Nlc3NOZXdDb2RlQmxvY2tzOiAoZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHZvaWQpID0+IE11dGF0aW9uT2JzZXJ2ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFJlYWRWaWV3KGFwcDogRXh0ZW5kZWRBcHAsIHNldHRpbmdzOiBDb2xsYXBzaWJsZUNvZGVCbG9ja1NldHRpbmdzKTogUmVhZFZpZXdBUEkge1xuICAgZnVuY3Rpb24gZ2V0RnJvbnRtYXR0ZXJDb2RlQmxvY2tTdGF0ZSgpOiBib29sZWFuIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgaWYgKCFhY3RpdmVWaWV3Py5maWxlKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBjYWNoZSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShhY3RpdmVWaWV3LmZpbGUpO1xuICAgICAgICBpZiAoIWNhY2hlPy5mcm9udG1hdHRlcj8uWydjb2RlLWJsb2NrcyddKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNhY2hlLmZyb250bWF0dGVyWydjb2RlLWJsb2NrcyddLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ2NvbGxhcHNlZCcpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdleHBhbmRlZCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9nZ2xlQnV0dG9uKCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSAnY29kZS1ibG9jay10b2dnbGUnO1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSBzZXR0aW5ncy5jb2xsYXBzZUljb247XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdUb2dnbGUgY29kZSBibG9jayB2aXNpYmlsaXR5Jyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0b2dnbGVIYW5kbGVyID0gKGU6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBwcmUgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmNsb3Nlc3QoJ3ByZScpO1xuICAgICAgICAgICAgaWYgKCFwcmUpIHJldHVybjtcblxuICAgICAgICAgICAgcHJlLmNsYXNzTGlzdC50b2dnbGUoJ2NvbGxhcHNlZCcpO1xuICAgICAgICAgICAgdXBkYXRlQ29kZUJsb2NrVmlzaWJpbGl0eShwcmUsIHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpc0NvbGxhcHNlZCA9IHByZS5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbGxhcHNlZCcpO1xuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gaXNDb2xsYXBzZWQgPyBzZXR0aW5ncy5leHBhbmRJY29uIDogc2V0dGluZ3MuY29sbGFwc2VJY29uO1xuICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICghaXNDb2xsYXBzZWQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgYXBwLndvcmtzcGFjZS5yZXF1ZXN0U2F2ZUxheW91dCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRvZ2dsZUhhbmRsZXIpO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgfHwgZS5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVIYW5kbGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvZGVCbG9ja1Zpc2liaWxpdHkocHJlOiBIVE1MRWxlbWVudCwgZm9yY2VSZWZyZXNoOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSBwcmUuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb2xsYXBzZWQnKTtcbiAgICAgICAgY29uc3QgbWFya2Rvd25WaWV3ID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGlmICghbWFya2Rvd25WaWV3Py5wcmV2aWV3TW9kZT8uY29udGFpbmVyRWwpIHJldHVybjtcblxuICAgICAgICBjb25zdCBwcmV2aWV3RWxlbWVudCA9IG1hcmtkb3duVmlldy5wcmV2aWV3TW9kZS5jb250YWluZXJFbDtcbiAgICAgICAgY29uc3QgcmVjdCA9IHByZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gcHJldmlld0VsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBlbGVtZW50VG9wID0gcmVjdC50b3AgKyBzY3JvbGxUb3A7XG5cbiAgICAgICAgbGV0IGN1cnIgPSBwcmUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB3aGlsZSAoY3VyciAmJiAhKGN1cnIgaW5zdGFuY2VvZiBIVE1MUHJlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyci5jbGFzc0xpc3QuYWRkKCdlbGVtZW50LWhpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyLmNsYXNzTGlzdC5yZW1vdmUoJ2VsZW1lbnQtdmlzaWJsZScsICdlbGVtZW50LXNwYWNpbmcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyLmNsYXNzTGlzdC5yZW1vdmUoJ2VsZW1lbnQtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnIuY2xhc3NMaXN0LmFkZCgnZWxlbWVudC12aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyciA9IGN1cnIubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdm9pZCBwcmUub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IHRyaWdnZXJSZWZsb3cgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3Jlc2l6ZScpKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpKTtcblxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTY3JvbGwgPSBwcmV2aWV3RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBwcmV2aWV3RWxlbWVudC5zY3JvbGxUb3AgPSBNYXRoLm1heCgwLCBwcmV2aWV3RWxlbWVudC5zY3JvbGxIZWlnaHQgLSBwcmV2aWV3RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzb2x2ZSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwcmV2aWV3RWxlbWVudC5zY3JvbGxUb3AgPSBvcmlnaW5hbFNjcm9sbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdyZXNpemUnKSk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgncmVzaXplJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyaWdnZXJSZWZsb3coKTtcbiAgICB9XG5cbiAgICAgZnVuY3Rpb24gc2V0dXBDb2RlQmxvY2socHJlOiBIVE1MRWxlbWVudCkge1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tY29sbGFwc2VkLWxpbmVzJywgc2V0dGluZ3MuY29sbGFwc2VkTGluZXMudG9TdHJpbmcoKSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0b2dnbGVCdXR0b24gPSBjcmVhdGVUb2dnbGVCdXR0b24oKTtcbiAgICAgICAgcHJlLmluc2VydEJlZm9yZSh0b2dnbGVCdXR0b24sIHByZS5maXJzdENoaWxkKTtcblxuICAgICAgICBjb25zdCBmcm9udG1hdHRlclN0YXRlID0gZ2V0RnJvbnRtYXR0ZXJDb2RlQmxvY2tTdGF0ZSgpO1xuICAgICAgICBjb25zdCBzaG91bGRDb2xsYXBzZSA9IGZyb250bWF0dGVyU3RhdGUgIT09IG51bGwgPyBmcm9udG1hdHRlclN0YXRlIDogc2V0dGluZ3MuZGVmYXVsdENvbGxhcHNlZDtcblxuICAgICAgICBpZiAoc2hvdWxkQ29sbGFwc2UpIHtcbiAgICAgICAgICAgIHByZS5jbGFzc0xpc3QuYWRkKCdjb2xsYXBzZWQnKTtcbiAgICAgICAgICAgIHRvZ2dsZUJ1dHRvbi50ZXh0Q29udGVudCA9IHNldHRpbmdzLmV4cGFuZEljb247XG4gICAgICAgICAgICB1cGRhdGVDb2RlQmxvY2tWaXNpYmlsaXR5KHByZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzTmV3Q29kZUJsb2NrcyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZTpub3QoLmhhcy1jb2xsYXBzZS1idXR0b24pJykuZm9yRWFjaChwcmUgPT4ge1xuICAgICAgICAgICAgaWYgKCEocHJlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHByZS5jbGFzc0xpc3QuYWRkKCdoYXMtY29sbGFwc2UtYnV0dG9uJywgJ2NjYi1jb2RlLWJsb2NrJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCBvdXIgY2xhc3MgdG8gdGhlIGNvZGUgZWxlbWVudCB0byB0YXJnZXQgc3R5bGluZ1xuICAgICAgICAgICAgY29uc3QgY29kZUVsZW1lbnQgPSBwcmUucXVlcnlTZWxlY3RvcignY29kZScpO1xuICAgICAgICAgICAgaWYgKGNvZGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29kZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2NiLWhpZGUtdmVydGljYWwtc2Nyb2xsYmFyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldHVwQ29kZUJsb2NrKHByZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwQ29udGVudE9ic2VydmVyKHByb2Nlc3NOZXdDb2RlQmxvY2tzOiAoZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHZvaWQpOiBNdXRhdGlvbk9ic2VydmVyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKG11dGF0aW9uID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05ld0NvZGVCbG9ja3MobXV0YXRpb24udGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvY2Vzc05ld0NvZGVCbG9ja3MsXG4gICAgICAgIHNldHVwQ29udGVudE9ic2VydmVyXG4gICAgfTtcbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQXdFOzs7QUNVakUsSUFBTSxtQkFBaUQ7QUFBQSxFQUMxRCxrQkFBa0I7QUFBQSxFQUNsQixjQUFjO0FBQUEsRUFDZCxZQUFZO0FBQUEsRUFDWix3QkFBd0I7QUFBQSxFQUN4QixnQkFBZ0I7QUFDcEI7OztBQ2ZBLGtCQUFrRTtBQUNsRSxzQkFBMkI7QUFDM0IsbUJBQXFEO0FBRXJELHNCQUFrQztBQU8zQixJQUFNLG1CQUFtQix5QkFBWSxPQUEyRDtBQUVoRyxJQUFNLGNBQU4sY0FBeUIsdUJBQVc7QUFBQSxFQVl2QyxZQUNhLFVBQ0EsUUFDQSxVQUNBLFdBQ0EsS0FDWDtBQUNFLFVBQU07QUFORztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUEsRUFHYjtBQUFBLEVBakJBLE9BQWUsNkJBQTZCLEtBQTBCO0FBakIxRTtBQWtCUSxVQUFNLGFBQWEsSUFBSSxVQUFVLG9CQUFvQiw0QkFBWTtBQUNqRSxRQUFJLEVBQUMseUNBQVk7QUFBTSxhQUFPO0FBQzlCLFVBQU0sUUFBUSxJQUFJLGNBQWMsYUFBYSxXQUFXLElBQUk7QUFDNUQsUUFBSSxHQUFDLG9DQUFPLGdCQUFQLG1CQUFxQjtBQUFnQixhQUFPO0FBQ2pELFVBQU0sUUFBUSxNQUFNLFlBQVks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QVEsVUFBUSxLQUNaLFNBQVMsS0FBSyxPQUFPLFNBQVMsWUFBWSxFQUMxQyxTQUFTLE9BQU8sVUFBVTtBQUN2QixZQUFNLFlBQVksTUFBTSxLQUFLO0FBQzdCLFVBQUksVUFBVSxVQUFVLEdBQUc7QUFDdkIsYUFBSyxPQUFPLFNBQVMsZUFBZSxhQUFhLGlCQUFpQjtBQUNsRSxjQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsTUFDbkM7QUFBQSxJQUNKLENBQUMsQ0FBQztBQUVWLFFBQUkseUJBQVEsV0FBVyxFQUNsQixRQUFRLGFBQWEsRUFDckIsUUFBUSw0RUFBNEUsRUFDcEYsUUFBUSxVQUFRLEtBQ1osU0FBUyxLQUFLLE9BQU8sU0FBUyxVQUFVLEVBQ3hDLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLFlBQU0sWUFBWSxNQUFNLEtBQUs7QUFDN0IsVUFBSSxVQUFVLFVBQVUsR0FBRztBQUN2QixhQUFLLE9BQU8sU0FBUyxhQUFhLGFBQWEsaUJBQWlCO0FBQ2hFLGNBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxNQUNuQztBQUFBLElBQ0osQ0FBQyxDQUFDO0FBRVYsUUFBSSx5QkFBUSxXQUFXLEVBQ2xCLFFBQVEsNkJBQTZCLEVBQ3JDLFFBQVEsb0VBQW9FLEVBQzVFLFVBQVUsWUFBVSxPQUNoQixTQUFTLEtBQUssT0FBTyxTQUFTLHNCQUFzQixFQUNwRCxTQUFTLE9BQU8sVUFBVTtBQUN2QixXQUFLLE9BQU8sU0FBUyx5QkFBeUI7QUFDOUMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUMvQixXQUFLLE9BQU8sb0JBQW9CO0FBQUEsSUFDcEMsQ0FBQyxDQUFDO0FBRVYsVUFBTSx3QkFBd0IsSUFBSSx5QkFBUSxXQUFXLEVBQ2hELFFBQVEsaUJBQWlCLEVBQ3pCLFFBQVEsc0RBQXNEO0FBSW5FLDBCQUFzQixRQUFRLFVBQVE7QUFDbEMsV0FDSyxTQUFTLEtBQUssT0FBTyxTQUFTLGVBQWUsU0FBUyxDQUFDLEVBQ3ZELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGNBQU0sZUFBZSxTQUFTLE9BQU8sRUFBRTtBQUN2QyxhQUFLLE9BQU8sU0FBUyxpQkFBaUIsTUFBTSxZQUFZLEtBQUssZUFBZSxJQUFJLElBQUk7QUFDcEYsY0FBTSxLQUFLLE9BQU8sYUFBYTtBQUcvQixpQkFBUyxnQkFBZ0IsTUFBTSxZQUFZLHFCQUFxQixLQUFLLE9BQU8sU0FBUyxlQUFlLFNBQVMsQ0FBQztBQUFBLE1BQ2xILENBQUM7QUFBQSxJQUNULENBQUM7QUFBQSxFQUNEO0FBQ0o7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicHJvY2Vzc05ld0NvZGVCbG9ja3MiXQp9Cg==
